<p>vim: foldmethod=expr ft=markdownlight</p>

<h1 id="libraries">Libraries</h1>
<ul>
  <li>forwardable, singleton, openstruct, delegate:
see metaprograming
http://ruby-doc.org/stdlib-2.2.0/libdoc/singleton/rdoc/Singleton.html
http://ruby-doc.org//stdlib-2.2.0/libdoc/forwardable/rdoc/Forwardable.html
http://ruby-doc.org/stdlib-2.1.0/libdoc/delegate/rdoc/Delegator.html
http://ruby-doc.org//stdlib-2.0/libdoc/ostruct/rdoc/OpenStruct.html</li>
  <li>Monitor
http://ruby-doc.org//stdlib-2.2.0/libdoc/monitor/rdoc/Monitor.html
To have locks</li>
  <li>rake:
https://github.com/ruby/rake
http://martinfowler.com/articles/rake.html</li>
</ul>

<h1 id="enumerable">Enumerable</h1>
<ul>
  <li>http://ruby-doc.org/core-2.2.0/Enumerable.html
all?(&amp;b),any?(&amp;b),one?(&amp;b),none?(&amp;b)
include? (=member?)
each_entry, each_cons, each_slice, each_with_index, each_with_object, reverse_each
select (=find_all), reject, map (=collect), flat_map, cycle, inject (=reduce)
find (=detect), find_all (=select), find_index, grep (comme ‘select’, mais
matche via patern === item)
first, drop, drop_while, take, take_while
group_by, partition, slice_when, slice_before, slice_after
count [can pass a value or a block and count the number of matching items]
min,min_by,max,max_by,minmax,minmax_by
sort,sort_by
lazy, to_a, to_h, to_set</li>
</ul>

<h1 id="enumerator">Enumerator</h1>
<ul>
  <li>http://ruby-doc.org/core-2.2.0/Enumerator.html
each(*appending_args,&amp;b)
with_index(num=0,&amp;b) [each_with_index = with_index(0)]
with_object(obj) (=each_with_object)
next, feed, next_values, peek, peek_values, inspect
rewind,size</li>
</ul>

<h1 id="array">Array</h1>
<ul>
  <li>http://ruby-doc.org//core-2.2.0/Array.html
Array.new(size, default) (or block for default)</li>
</ul>

<p>Array#slice (= []): array[el], array[start,length], array[range]
Array#fill (= []=); Array#slice! [delete the sliced elements]
each, each_index
at, values_at(*index), fetch, assoc, rassoc, bsearch, find_index (=index), rindex, sample
first, last, take, drop, drop_while, select, reject #non destructive
push (=«), pop, unshift, shift
clear, delete, delete_at, delete_if, reject!, keep_if, insert, replace
[reject! returns nil if no changes were made, delete_if always return the array]
size (=length) count [like size but can take a value or a block]
empty?, include?
compact, compact!, uniq, uniq!, sort, sort!, sort_by!, map! (=collect!), flatten, flatten!, reverse, reverse!, rotate, rotate!, shuffle, shuffle!
combination, repeated_combination, product, permutation, repeated_permutation, zip
&amp;, *, +, -, | [union]
join, pack, transpose, to_a, to_h</p>

<h1 id="hash">Hash</h1>
<ul>
  <li>http://ruby-doc.org//core-2.2.0/Hash.html
Hash[key,value…], Hash[[key,value],…],Hash[obj]
Hash.new,Hash.new(obj),Hash.new {|hash,key|}
assoc, rassoc, fetch, key, keys, values, values_at, store (= []=)
each (=each_pair), each_key, each_value
clear, compare_by_identity[?], default, default_proc
delete(key,&amp;b),delete_if, keep_if, select, reject
empty?, has_key? (=include?,key?,member?), has_value? (=value?)
to_a, flatten(level), invert, merge[!] (merge!=update), replace, shift
length (=size)</li>
</ul>

<h1 id="set">Set</h1>
<ul>
  <li>http://ruby-doc.org//stdlib-2.1.1//libdoc/set/rdoc/Set.html</li>
</ul>

<p>Set[*elts], Set.new(enumerable)
- proper_subset? (= &lt;), subset? (= &lt;=), proper_superset? (= &gt;), superset? (= &gt;=)
- intersection(enum) (= &amp;), difference(enum) (= -, =substract), union (= |, =+), ^ (xor)
- add (= «), add?, delete, delete?, delete_if, reject!, keep_if, select!, merge, replace
- include?, member?, disjoint?, intersect?, empty?
- classify, divide
- map! (=collect!), flatten, flatten!
- length (=size)</p>

<h1 id="string">String</h1>
<ul>
  <li>http://ruby-doc.org//core-2.2.0/String.html
Rem: not exhaustive; the rule for ‘count’ is used by ‘delete’ and ‘squeeze’</li>
</ul>

<p>slice[!]: str[index], str[index,length], str[range], str[regexp], str[regexp,capture], str[str2]
index, rindex
*, % (=sprintf), scan
each_char, each_line, lines, chars [=each_char.to_a], chr [first character]
chomp<a href="separtor=$/">!</a>, chop[!], lstrip[!], rstrip[!], strip[!], squeeze[!]
count, size (=length)
empty?, end_with?, include?, start_with?
replace, insert, delete[!], concat (= «) [like + but convert to string], prepend
capitalize[!], center, clear, downcase[!], dump, ljust, reverse[!], rjust, swapcase, upcase[!]
encode, scrub[!], unpack
gsub[!], sub[!], match, split, tr[!]
next[!] (=succ), upto, partition, rpartition, sum, casecmp
intern (= to_sym), to_c,to_f,to_i,to_r,to_s,to_str,to_sym</p>

<h1 id="time">Time</h1>
<p>## Time in standard library
- http://ruby-doc.org//core-2.2.0/Time.html
- http://ruby-doc.org/stdlib-2.0/libdoc/time/rdoc/Time.html
  (available with require ‘time’: more conversion methods)</p>

<p>Time vs DateTime
- http://stackoverflow.com/questions/1261329/whats-the-difference-between-datetime-and-time-in-ruby
- http://stackoverflow.com/questions/5941613/are-the-date-time-and-datetime-classes-necessary
Summary: use Date if you only want to deal with dates
DateTime is like a Date+Time, but DateTime does not consider any leapseconds, does not track any summer time rules.
So except if you want to ignore DST, use Time (before Time date range was
limited, but now it uses a 63bits integer so it can represent a large
range)</p>

<p>Constructing time:
Time.local(year,month…),Time.gm(year,month…),Time.iso8601,Time.xmlschema,Time.httpdate,Time.utc,Time.rfc2822
Time.now,Time.parse,Time.at(seconds)…
Conversion: t.iso8601=t.xmlschema,t.rfc2822=t.rfc922,t.httpdate,t.utc,t.localtime</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">require</span> <span class="n">time</span>
  <span class="n">t</span><span class="o">=</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
  <span class="c1">#=&gt; 2012-11-30 17:31:13 +0100</span>
  
  <span class="n">t</span><span class="p">.</span><span class="nf">iso8601</span> <span class="c1">#=t.xmlschema</span>
  <span class="c1">#=&gt; "2012-11-30T17:31:13+01:00"</span>
  <span class="no">Time</span><span class="p">.</span><span class="nf">iso8601</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="nf">iso8601</span><span class="p">)</span>
  <span class="c1">#=&gt; 2012-11-30 16:31:13 UTC</span>
  
  <span class="n">t</span><span class="p">.</span><span class="nf">rfc2822</span> <span class="c1">#=t.rfc822</span>
  <span class="c1">#=&gt; "Fri, 30 Nov 2012 17:31:13 +0100"</span>
  <span class="no">Time</span><span class="p">.</span><span class="nf">rfc2822</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="nf">rfc2822</span><span class="p">)</span>
  <span class="c1">#=&gt; 2012-11-30 16:31:13 UTC</span>
  
  <span class="n">t</span><span class="p">.</span><span class="nf">utc</span>
  <span class="c1">#=&gt; 2012-11-30 16:31:13 UTC</span>
  <span class="n">t</span><span class="p">.</span><span class="nf">httpdate</span>
  <span class="c1">#=&gt; "Fri, 30 Nov 2012 16:31:13 GMT"</span>
  <span class="no">Time</span><span class="p">.</span><span class="nf">httpdate</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="nf">httpdate</span><span class="p">)</span> <span class="c1">#parse a httpdate date</span>
  <span class="c1">#=&gt; 2012-11-30 17:31:13 +0100</span>
  
  <span class="no">Time</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="s2">"11/2012"</span><span class="p">)</span>
  <span class="c1">#=&gt; 2012-11-01 00:00:00 +0100</span>
  <span class="no">Time</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="s2">"11/11"</span><span class="p">)</span>
  <span class="c1">#=&gt; 2012-11-11 00:00:00 +0100</span>
  
  <span class="c1">#Time.parse marche sur xmlschema, rfc2822 et httpdate</span>
  <span class="c1">#Chronic.parse ne marche que sur xmlschema</span>
  
  <span class="c1">#Ex: optparse/time est donné par</span>
  <span class="nb">require</span> <span class="s1">'optparse'</span>
  <span class="nb">require</span> <span class="s1">'time'</span>
  <span class="no">OptionParser</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="no">Time</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="p">,</span><span class="o">|</span>
    <span class="k">begin</span>
      <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">httpdate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">rescue</span> <span class="no">Time</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="k">if</span> <span class="n">s</span>
    <span class="k">rescue</span>
      <span class="k">raise</span> <span class="no">OptionParser</span><span class="o">::</span><span class="no">InvalidArgument</span><span class="p">,</span> <span class="n">s</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<h2 id="time-with-active-support">Time with active support</h2>
<p>http://danilenko.org/2012/7/6/rails_timezones/
=&gt; require ‘active_support/time’
Can use a timezone different from the system time zone
Time.zone=’CET’
Time.zone.class #=&gt; ActiveSupport::TimeZone
Time.zone.now
-&gt; Adds Time#in_time_zone:
Returns the simultaneous time in <tt>Time.zone</tt> if a zone is given or
if Time.zone_default is set. (set by Time.zone=…)
-&gt; Or if tz is a TimeZone we have tz.at(time):
Method for creating new ActiveSupport::TimeWithZone instance in time zone
of self from number of seconds since the Unix epoch.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'active_support/all'</span>
<span class="n">tz</span><span class="o">=</span><span class="no">ActiveSupport</span><span class="o">::</span><span class="no">TimeZone</span><span class="p">[</span><span class="s1">'Europe/Paris'</span><span class="p">]</span> <span class="c1">#alias for ActiveSupport::TimeZone.new("Europe/Paris") #=&gt; (GMT+01:00) Europe/Paris</span>
<span class="no">Time</span><span class="p">.</span><span class="nf">zone</span><span class="o">=</span><span class="s2">"Alaska"</span> <span class="c1">#default time zone</span>
<span class="n">tz</span><span class="o">=</span><span class="no">ActiveSupport</span><span class="o">::</span><span class="no">TimeZone</span><span class="p">[</span><span class="s1">'America/Los_Angeles'</span><span class="p">]</span>
<span class="n">t</span><span class="o">=</span><span class="no">Time</span><span class="p">.</span><span class="nf">local</span><span class="p">(</span><span class="mi">2012</span><span class="p">)</span> <span class="c1">#=&gt; 2012-01-01 00:00:00 +0100</span>
<span class="n">t</span><span class="p">.</span><span class="nf">zone</span> <span class="c1">#=&gt; "CET"</span>
<span class="n">t</span><span class="p">.</span><span class="nf">in_time_zone</span> <span class="c1">#=&gt; Sat, 31 Dec 2011 14:00:00 AKST -09:00</span>
<span class="n">t</span><span class="p">.</span><span class="nf">in_time_zone</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span> <span class="c1">#=&gt; Sat, 31 Dec 2011 15:00:00 PST -08:00</span>
<span class="n">t</span><span class="p">.</span><span class="nf">in_time_zone</span><span class="p">(</span><span class="s2">"Europe/Paris"</span><span class="p">)</span> <span class="c1">#=&gt; Sun, 01 Jan 2012 00:00:00 CET +01:00</span>
<span class="no">Time</span><span class="p">.</span><span class="nf">zone</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1"># =&gt; Sat, 31 Dec 2011 14:00:00 AKST -09:00</span>
<span class="n">tz</span><span class="p">.</span><span class="nf">at</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1">#=&gt; Sat, 31 Dec 2011 15:00:00 PST -08:00</span>
<span class="no">Time</span><span class="p">.</span><span class="nf">current</span> <span class="c1">#=&gt; Thu, 26 Feb 2015 02:13:43 AKST -09:00</span>
<span class="no">Time</span><span class="p">.</span><span class="nf">zone</span><span class="p">.</span><span class="nf">now</span> <span class="c1">#=&gt; Thu, 26 Feb 2015 02:16:32 AKST -09:00</span>
  <span class="c1"># Where Time.zone.now is</span>
  <span class="c1"># class ActiveSupport::TimeZone</span>
  <span class="c1">#   def now</span>
  <span class="c1">#     Time.now.utc.in_time_zone(self)</span>
  <span class="c1">#   end</span>
  <span class="c1"># end</span>
  <span class="c1"># And Time#current is</span>
  <span class="c1"># def current</span>
  <span class="c1">#   ::Time.zone ? ::Time.zone.now : ::Time.now</span>
  <span class="c1"># end</span>
</code></pre></div></div>

<p>(Active support add Time.current() (like Time.now() but with time zone
in Time.zone_default.)
By default Time.now.zone use the system time zone:
Time.new(2012): 2012 in system time zone #in std lib
Time.local_time(2012): 2012 in user time zone
Time.utc_time(2012): 2012 in utc time zone
Also add things like now=Time.current, now+1.year</p>

<h1 id="logger">Logger</h1>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'logger'</span>

<span class="n">logger</span> <span class="o">=</span> <span class="no">Logger</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">STDOUT</span><span class="p">)</span>
<span class="n">logger</span><span class="p">.</span><span class="nf">level</span> <span class="o">=</span> <span class="no">Logger</span><span class="o">::</span><span class="no">WARN</span>

<span class="n">logger</span><span class="p">.</span><span class="nf">debug</span><span class="p">(</span><span class="s2">"Created logger"</span><span class="p">)</span>
<span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s2">"Program started"</span><span class="p">)</span>
<span class="n">logger</span><span class="p">.</span><span class="nf">warn</span><span class="p">(</span><span class="s2">"Nothing to do!"</span><span class="p">)</span>

<span class="n">original_formatter</span> <span class="o">=</span> <span class="no">Logger</span><span class="o">::</span><span class="no">Formatter</span><span class="p">.</span><span class="nf">new</span>
<span class="n">logger</span><span class="p">.</span><span class="nf">formatter</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="n">severity</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">progname</span><span class="p">,</span> <span class="n">msg</span><span class="o">|</span>
  <span class="n">original_formatter</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">severity</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">progname</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="nf">dump</span><span class="p">)</span>
<span class="p">}</span>

 <span class="c1"># 4. Create a logger which ages the logfile once it reaches a certain size.</span>
 <span class="c1">#    Leave 10 "old" log files where each file is about 1,024,000 bytes.</span>
<span class="n">logger</span> <span class="o">=</span> <span class="no">Logger</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'foo.log'</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1024000</span><span class="p">)</span>

 <span class="c1"># 5. Create a logger which ages the logfile daily/weekly/monthly.</span>
<span class="n">logger</span> <span class="o">=</span> <span class="no">Logger</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'foo.log'</span><span class="p">,</span> <span class="s1">'daily'</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="no">Logger</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'foo.log'</span><span class="p">,</span> <span class="s1">'weekly'</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="no">Logger</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'foo.log'</span><span class="p">,</span> <span class="s1">'monthly'</span><span class="p">)</span>

 <span class="c1"># Level:</span>
<span class="no">Logger</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">logdev</span><span class="p">,</span> <span class="ss">level: :info</span><span class="p">)</span> <span class="c1"># 'INFO' / Logger::INFO</span>

 <span class="c1"># Default log format:</span>
 <span class="c1">#    SeverityID, [DateTime #pid] SeverityLabel -- ProgName: message</span>
 <span class="c1"># =&gt; I, [1999-03-03T02:34:24.895701 #19074]  INFO -- Main: info.</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">logdev</span><span class="p">,</span> <span class="n">shift_age</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shift_size</span> <span class="o">=</span> <span class="mi">1048576</span><span class="p">,</span> <span class="ss">level: </span><span class="no">DEBUG</span><span class="p">,</span>
               <span class="ss">progname: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">formatter: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">datetime_format: </span><span class="kp">nil</span><span class="p">,</span>
               <span class="ss">shift_period_suffix: </span><span class="s1">'%Y%m%d'</span><span class="p">)</span>
<span class="k">end</span>
<span class="nb">attr_accessor</span> <span class="ss">:progname</span><span class="p">,</span> <span class="ss">:formatter</span>
<span class="n">datetime_format</span><span class="o">=</span>

<span class="k">def</span> <span class="nf">level</span><span class="o">=</span><span class="p">(</span><span class="n">severity</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">severity</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Integer</span><span class="p">)</span>
    <span class="vi">@level</span> <span class="o">=</span> <span class="n">severity</span>
  <span class="k">else</span>
    <span class="k">case</span> <span class="n">severity</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">downcase</span>
    <span class="k">when</span> <span class="s1">'debug'</span>
      <span class="vi">@level</span> <span class="o">=</span> <span class="no">DEBUG</span>
    <span class="o">...</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

  <span class="no">Logger</span><span class="c1">#add(severity, message = nil, progname = nil) { ... }</span>
  <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">severity</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">progname</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
    <span class="n">severity</span> <span class="o">||=</span> <span class="no">UNKNOWN</span>
    <span class="k">if</span> <span class="vi">@logdev</span><span class="p">.</span><span class="nf">nil?</span> <span class="n">or</span> <span class="n">severity</span> <span class="o">&lt;</span> <span class="vi">@level</span>
      <span class="k">return</span> <span class="kp">true</span>
    <span class="k">end</span>
    <span class="k">if</span> <span class="n">progname</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="n">progname</span> <span class="o">=</span> <span class="vi">@progname</span>
    <span class="k">end</span>
    <span class="k">if</span> <span class="n">message</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="k">if</span> <span class="nb">block_given?</span>
        <span class="n">message</span> <span class="o">=</span> <span class="k">yield</span>
      <span class="k">else</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">progname</span>
        <span class="n">progname</span> <span class="o">=</span> <span class="vi">@progname</span>
      <span class="k">end</span>
    <span class="k">end</span>
    <span class="vi">@logdev</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span>
      <span class="n">format_message</span><span class="p">(</span><span class="n">format_severity</span><span class="p">(</span><span class="n">severity</span><span class="p">),</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">,</span> <span class="n">progname</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
    <span class="kp">true</span>
  <span class="k">end</span>

  <span class="c1">#   Logger#info(message)</span>
  <span class="c1">#   Logger#info(progname, &amp;block)</span>
  <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="n">progname</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">add</span><span class="p">(</span><span class="no">INFO</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">progname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">format_message</span><span class="p">(</span><span class="n">severity</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">progname</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">(</span><span class="vi">@formatter</span> <span class="o">||</span> <span class="vi">@default_formatter</span><span class="p">).</span><span class="nf">call</span><span class="p">(</span><span class="n">severity</span><span class="p">,</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">progname</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre></div></div>
