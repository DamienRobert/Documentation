<p>vim: foldmethod=expr ft=markdownlight</p>

<h1 id="libraries">Libraries</h1>

<p>python completion: https://docs.python.org/2/tutorial/interactive.html
Standard gui: idle</p>

<p>Better interpreters: bpython (automatically show interface of functions), and ipython (more complete, with a gui: ipython qtconsole), ptpython (not on archlinux)
See: http://www.pythoncentral.io/review-of-bpython-and-dreampie-alternative-python-shells/
jupyter: web notebook (extracted from ipython as a separate component;
‘jupyter notebook’ stores files as *.ipynb in the $PWD)</p>

<p>Packaging:
see http://stackoverflow.com/questions/6344076/differences-between-distribute-distutils-setuptools-and-distutils2
and http://xahlee.info/python/python_whats_pip_easyinstall_setuptools.html
Summary: pip is more powerfull than easy_install which is itself more
flexible than the original ‘python setup.py install’
To build package use ‘distutils’ (in the stdlib) or ‘setuptools’ if more
features are needed.</p>

<p>Virtualenv: https://wiki.archlinux.org/index.php/Python_VirtualEnv</p>

<h1 id="scope">Scope</h1>

<p>http://stackoverflow.com/questions/291978/short-description-of-python-scoping-rules
LEGB Rule.
L. Local. (Names assigned in any way within a function (def or lambda)), and not declared global in that function.
E. Enclosing function locals. (Name in the local scope of any and all enclosing functions (def or lambda), form inner to outer.
G. Global (module). Names assigned at the top-level of a module file, or declared global in a def within the file.
B. Built-in (Python). Names preassigned in the built-in names module : open,range,SyntaxError,…</p>

<p>Les fonctions ne forment pas des closures, mais comme elles ouvrent un
nouveau scope on peut faire une closure en emboitant une fonction dans une
fonction:
x=0
def f(y): return x+y
f(3) #=&gt; 3
x=1; f(3) #=&gt; 4</p>

<p>def f(x):
  def g(y): return x+y
  return g
g=f(2) #cloture x-&gt;2+x</p>

<p>Scopes modifier: global, nonlocal (for nested function scopes)</p>

<h1 id="packages">Packages</h1>
<ul>
  <li>https://docs.python.org/3/reference/import.html</li>
</ul>

<p>Unlike in ruby, in python
‘import foo’
put all the names of foo.py into the ‘foo’ namespace.
To flatten the namespace, do
‘from foo import ploum, plam’ or ‘from foo import *’
Use ‘import foo.bar’ to refer to the package foo/bar.py</p>

<ul>
  <li>
    <p>Regular package:
« Python defines two types of packages, regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an <strong>init</strong>.py file. When a regular package is imported, this <strong>init</strong>.py file is implicitly executed, and the objects it defines are bound to names in the package’s namespace. The <strong>init</strong>.py file can contain the same Python code that any other module can contain, and Python will add some additional attributes to the module when it is imported. »</p>
  </li>
  <li>
    <p>python 3.3 implicit namespace package:
      If <directory>/foo/__init__.py is found, a regular package is imported and returned.
      If not, but <directory>/foo.{py,pyc,so,pyd} is found, a module is imported and returned. The exact list of extension varies by platform and whether the -O flag is specified. The list here is representative.
      If not, but <directory>/foo is found and is a directory, it is recorded and the scan continues with the next directory in the parent path.
      Otherwise the scan continues with the next directory in the parent path.
If the scan completes without returning a module or package, and at least one directory was recorded, then a namespace package is created. The new namespace package:
      Has a __path__ attribute set to an iterable of the path strings that were found and recorded during the scan.
      Does not have a __file__ attribute.</directory></directory></directory></p>
  </li>
</ul>

<p>Then import foo.bar
will create the namespace foo (with contains as <strong>path</strong> all the directory
foo/ found till now)
and then load the package bar in one of the foo found</p>

<p>Example:
Feanor /tmp/python $ tree                                                   ⚡25
├── foo1
│   └── baz
│       └── bar.py
├── foo2
│   └── baz
│       └── bar.py
└── main.py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">#foo1/baz/bar.py:
</span><span class="n">bar1</span><span class="o">=</span><span class="s">"foo1"</span>
 <span class="c1">#foo2/baz/bar.py:
</span><span class="n">bar2</span><span class="o">=</span><span class="s">"foo2"</span>
 <span class="c1"># main.py:
</span><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span> <span class="o">+=</span> <span class="p">[</span><span class="s">'foo1'</span><span class="p">,</span> <span class="s">'foo2'</span><span class="p">]</span>
<span class="kn">import</span> <span class="nn">baz.bar</span>
<span class="k">print</span><span class="p">(</span><span class="n">baz</span><span class="o">.</span><span class="n">__path__</span><span class="p">)</span> <span class="c1">#=&gt;_NamespacePath(['foo1/baz', 'foo2/baz'])
</span><span class="k">print</span><span class="p">(</span><span class="n">baz</span><span class="o">.</span><span class="n">bar</span><span class="o">.</span><span class="n">bar1</span><span class="p">)</span> <span class="c1">#=&gt; foo1
</span><span class="k">print</span><span class="p">(</span><span class="n">baz</span><span class="o">.</span><span class="n">bar</span><span class="o">.</span><span class="n">bar2</span><span class="p">)</span>
 <span class="c1">#=&gt;
</span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"main.py"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">6</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="k">print</span><span class="p">(</span><span class="n">baz</span><span class="o">.</span><span class="n">bar</span><span class="o">.</span><span class="n">bar2</span><span class="p">)</span>
<span class="nb">AttributeError</span><span class="p">:</span> <span class="s">'module'</span> <span class="nb">object</span> <span class="n">has</span> <span class="n">no</span> <span class="n">attribute</span> <span class="s">'bar2'</span>
</code></pre></div></div>
<p>In this case still only the first ‘bar.py’ found is loaded.
Still if we rename foo2/baz/bar.py into foo2/baz/bar2.py, then
‘import baz.bar2’ would work because due to packages namespaces, ‘baz’
refer to both ‘foo1/baz’ and ‘foo2/baz’ (cf the NamespacePath above)</p>

<ul>
  <li>Note on names:
By default names with a leading underscore are not imported by import *.
This can be customized by setting the <strong>all</strong> variable, to set up the
variables imported by import *</li>
</ul>

<p>http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python
- _single_leading_underscore: weak “internal use” indicator. E.g. from M
  import * does not import objects whose name starts with an underscore.
- Any identifier of the form <strong>spam (at least two leading underscores, at
  most one trailing underscore) is textually replaced with
  _classname__spam, where classname is the current class name with leading
  underscore(s) stripped. This mangling is done without regard to the
  syntactic position of the identifier, so it can be used to define
  class-private instance and class variables, methods, variables stored in
  globals, and even variables stored in instances. private to this class on
  instances of other classes.
- names __foo</strong> are internal to python
~~~ python
»&gt; class MyClass():
…     def <strong>init</strong>(self):
…             self.__superprivate = “Hello”
…             self._semiprivate = “, world!”
…
»&gt; mc = MyClass()
»&gt; print mc.__superprivate
Traceback (most recent call last):
  File “<stdin>", line 1, in <module>
AttributeError: myClass instance has no attribute '__superprivate'
&gt;&gt;&gt; print mc._semiprivate
, world!
&gt;&gt;&gt; print mc.__dict__
{'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'}
~~~</module></stdin></p>

<h1 id="syntax">Syntax</h1>

<h2 id="python2-vs-python3">python2 vs python3</h2>

<p>In python2 strings are byte strings, use u’string’ to get unicode strings:
  len(“éà”) #=&gt;4
  len(u”éà”) #=&gt;2
  b”éà”==”éà” #=&gt;True
open(file) reads binary file, the only effect of passing ‘b’ to the flags is
that no line conversion is done
  open(“/tmp/ploum”).read()
  ‘\xc3\xa9\nploum\n’
To open in utf-8:
  import codecs
  f = codecs.open(filename, encoding=”utf-8”)</p>

<p>In python3 strings are unicode strings, use b’string’ to get byte streams
  u”éà”==”éà” #=&gt;True
open(file) reads a unicode text, passing ‘b’ switchs to binary mode
  »&gt; open(“/tmp/ploum”).read()
  ‘é\nploum\n’
  »&gt; open(“/tmp/ploum”,’rb’).read()
  b’\xc3\xa9\nploum\n’</p>

<p>In python2 ‘print’ is a keyword, while in python3 it is a function call</p>

<h2 id="statements">Statements</h2>

<p>if test:
  block
elif test:
  block
else:
  block
end</p>

<p>if test: simple_statement1; simple_statement2
else: simple_statement3</p>

<p>x if y else z</p>

<p>for x in ploum:
  block
  if test: continue
  if test: break
else:
  block #called when there was no break</p>

<p>Examples:
for value in [1,2,3]: …
for index,value in enumerate([1,2,3]): …
h={“ploum”: “plam”, “plim”: “plom”}
for k in {“ploum”: “plam”, “plim”: “plom”}: h[k]
for k,v in h.items(): k,v</p>

<p>while test:
  block
  if test: continue
  if test: break
else:
  block #called when there was no break</p>

<p>try:
  block
except ValueError:
  block
except:
  block #catch all other errors
else:
  block #no errors
finally:
  block</p>

<h2 id="comprehension">Comprehension</h2>

<p>squares = [x**2 for x in range(10)] #list comprehension
[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
matrix = [
     [1, 2, 3, 4],
     [5, 6, 7, 8],
     [9, 10, 11, 12],
]
[[row[i] for row in matrix] for i in range(len(matrix[1])] #nested comprehension to transpose a matrix</p>

<p>{ x for x in range(10) } #set comprehension
{ x:x+1 for x in range(10) } #hash comprehension
( x for x in range(10) ) #generator</p>

<h2 id="slices">Slices</h2>

<p>l=list(range(10))
l[:] #do a copy
l[1:3] #=&gt; [1,2]
l[2:5:2] #=&gt; [2,4]
l[5:2:-2] #=&gt; [5,3]
l[::-1] #=&gt; like l.revese() but do a copy</p>

<h2 id="assignement">Assignement</h2>

<p>a,*b,c=[1,2,3,4] #=&gt; a=1, b=[2,3], c=4 #splat (like ruby)
(a,b),c=[(1,2),3] #stacked assignement (like ruby), a=1,b=2,c=3
a,(b,c)=(1,2),(3,4) #another example (like ruby): a=(1,2), b=3, c=4</p>

<h2 id="functions">Functions</h2>

<p>def foo(a,b=1,*args,c=5,**keywords):
  print(a,b,args,c,keywords)
foo(0) #=&gt; 0, 1, (), 5, {}
foo(0,2) #=&gt; 0, 2, (), 5, {}
foo(b=3,a=1) #=&gt; 1, 3, (), 5, {}
foo(2,3,4) #=&gt; 2 3 (4,) 5 {}
foo(2,3,4,5) #=&gt; 2 3 (4, 5) 5 {}
foo(2,3,4,5,c=0, e=1, f=2) #=&gt; 2 3 (4, 5) 0 {‘e’: 1, ‘f’: 2}</p>

<h2 id="lambda">Lambda</h2>

<p>f=lambda x: x+1
lambda x,y: x+y
(a lambda can only contain an expression, not several statements)</p>

<h1 id="generators">Generators</h1>
<p>## Generators as iterators
https://www.python.org/dev/peps/pep-0255/
https://wiki.python.org/moin/Generators
~~~ python
 # a generator that yields items instead of returning a list
def firstn(n):
    num = 0
    while num &lt; n:
        yield num
        num += 1</p>

<p>sum_of_first_n = sum(firstn(1000000))</p>

<p># Using the generator pattern (an iterable) via a class
class firstn(object):
    def <strong>init</strong>(self, n):
        self.n = n
        self.num = 0
    def <strong>iter</strong>(self):
        return self
    # Python 3 compatibility
    def <strong>next</strong>(self):
        return self.next()
    def next(self):
        if self.num &lt; self.n:
            cur, self.num = self.num, self.num+1
            return cur
        else:
            raise StopIteration()</p>

<p>#square is a generator
square = (i*i for i in range(1000000))
 #add the squares
total = 0
for i in square:
   total += i
~~~</p>

<h2 id="generators-as-coroutine">Generators as coroutine:</h2>
<p>https://www.python.org/dev/peps/pep-0342/
https://docs.python.org/2/reference/expressions.html</p>

<p>Voir aussi les references: https://marcarea.com/weblog/2016/04/06/coroutines-via-generateurs-ameliores-en-python
- Using Generators As an Alternative to Threads: http://chimera.labs.oreilly.com/books/1230000000393/ch12.html#_solution_208
- Generator Tricks for Systems Programmers: http://www.dabeaz.com/generators-uk/</p>

<p>generator.next() [this is like generator.send(None)]
      Starts the execution of a generator function or resumes it at the last executed yield expression. When a generator function is resumed with a next() method, the current yield expression always evaluates to None. The execution then continues to the next yield expression, where the generator is suspended again, and the value of the expression_list is returned to next()‘s caller. If the generator exits without yielding another value, a StopIteration exception is raised.</p>

<p>generator.send(value)
      Resumes the execution and “sends” a value into the generator function. The value argument becomes the result of the current yield expression. The send() method returns the next value yielded by the generator, or raises StopIteration if the generator exits without yielding another value. When send() is called to start the generator, it must be called with None as the argument, because there is no yield expression that could receive the value.</p>

<p>generator.throw(type[, value[, traceback]])
      Raises an exception of type type at the point where generator was paused, and returns the next value yielded by the generator function. If the generator exits without yielding another value, a StopIteration exception is raised. If the generator function does not catch the passed-in exception, or raises a different exception, then that exception propagates to the caller.</p>

<p>generator.close()
      Raises a GeneratorExit at the point where the generator function was paused. If the generator function then raises StopIteration (by exiting normally, or due to already being closed) or GeneratorExit (by not catching the exception), close returns to its caller. If the generator yields a value, a RuntimeError is raised. If the generator raises any other exception, it is propagated to the caller. close() does nothing if the generator has already exited due to an exception or normal exit.</p>

<p>Here is a simple example that demonstrates the behavior of generators and generator functions:
»&gt;</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>def echo(value=None):
…     print “Execution starts when ‘next()’ is called for the first time.”
…     try:
…         while True:
…             try:
…                 value = (yield value)
…             except Exception, e:
…                 value = e
…     finally:
…         print “Don’t forget to clean up when ‘close()’ is called.”
…
generator = echo(1)
print generator.next() #generator.<strong>next</strong>() in python3
Execution starts when ‘next()’ is called for the first time.
1
print generator.next()
None
print generator.send(2)
2
generator.throw(TypeError, “spam”)
TypeError(‘spam’,)
generator.close()
Don’t forget to clean up when ‘close()’ is called.</p>
    </blockquote>
  </blockquote>
</blockquote>

<h2 id="yield-from">yield from</h2>
<p>https://www.python.org/dev/peps/pep-0380/
New syntax in python3.3 to delegate to a subgenerator: yield from https://docs.python.org/dev/whatsnew/3.3.html#pep-380-syntax-for-delegating-to-a-subgenerator</p>

<p>Note that this syntax allows generators to return a value which will be
wrapped by StopIteration(value). This value is the result value of ‘yield
from’. But this mean that StopIteration exception was not distinguished
from its use as a return value, so a normal StopIteration is wrapped into
RuntimeError; cf https://www.python.org/dev/peps/pep-0479/</p>

<p>‘yield from g’ is equivalent to ‘for v in g: yield v’
except it also handles sending values or throwing exceptions to the generator
ie handles generator as coroutines: 
- http://stackoverflow.com/questions/9708902/in-practice-what-are-the-main-uses-for-the-new-yield-from-syntax-in-python-3
- http://simeonvisser.com/posts/python-3-using-yield-from-in-generators-part-2.html</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generator2</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">i</span>
<span class="k">def</span> <span class="nf">generator3</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">j</span>

<span class="k">def</span> <span class="nf">generator</span><span class="p">():</span>
    <span class="k">yield</span> <span class="k">from</span> <span class="n">generator2</span><span class="p">()</span>
    <span class="k">yield</span> <span class="k">from</span> <span class="n">generator3</span><span class="p">()</span>
</code></pre></div></div>

<p>Cf https://dl.dropboxusercontent.com/u/44884329/yield-from.pdf
How Python 3.3 “yield from” construct works</p>

<p>yield from is an expression:
 The value of the yield from expression is the first argument to the StopIteration exception raised by the iterator when it terminates.
return expr in a generator causes StopIteration(expr) to be raised upon exit from the generator.</p>

<h2 id="coroutines-with-asyncawait">Coroutines with async/await</h2>
<p>https://www.python.org/dev/peps/pep-0492/
https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/
http://benno.id.au/blog/2015/05/25/await1</p>

<p>async def py35_coro():
    await stuff()</p>

<p>https://docs.python.org/3/reference/datamodel.html#coroutines
An awaitable object generally implements an <strong>await</strong>() method. Coroutine objects returned from async def functions are awaitable.</p>

<p>‘await’ = ‘yield from’, except it takes a coroutine as argument, ie an awaitable object rather than a generator (the two are similar but the types are different to distinguish between the usage;  It was a SyntaxError to have yield or yield from expressions in an async function; now by PEP 525 a yield in a async function generates an asynchronous generator)
‘async def’ transforms a function into a coroutine.
A generator can also be flagged as a coroutine using the decorator ‘@types.coroutine’, it then becomes awaitable and can yield from an async def coroutine.</p>

<p>One can start an async def coroutine with coroutine().send(None)</p>

<p>https://www.python.org/dev/peps/pep-0492/
 await , similarly to yield from, suspends execution of read_data coroutine until db.fetch awaitable completes and returns the result data.
It uses the yield from implementation with an extra step of validating its argument. await only accepts an awaitable , which can be one of:
  - A native coroutine object returned from a native coroutine function .
  - A generator-based coroutine object returned from a function decorated with types.coroutine() .
  - An object with an <strong>await</strong> method returning an iterator.
Also gives examples of ‘async with’ and ‘async for’ (cf below)</p>

<p>Example: https://docs.python.org/3/library/asyncio.html
~~~ python
async def display_date(loop):
    end_time = loop.time() + 5.0
    while True:
        print(datetime.datetime.now())
        if (loop.time() + 1.0) &gt;= end_time:
            break
        await asyncio.sleep(1)</p>

<p>@types.coroutine
def display_date(loop):
    end_time = loop.time() + 5.0
    while True:
        print(datetime.datetime.now())
        if (loop.time() + 1.0) &gt;= end_time:
            break
        yield from asyncio.sleep(1)
~~~</p>

<p>asynchronous iteration protocol (async for): define a class that implements <strong>aiter</strong> and <strong>anext</strong> to be able to use it in an async for statement.  <strong>anext</strong> must returns an awaitable</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AsyncIterable</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_data</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">StopAsyncIteration</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">fetch_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

<span class="k">async</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">Cursor</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="c1">#would be equivalent to the following code:
</span><span class="n">i</span> <span class="o">=</span> <span class="n">Cursor</span><span class="p">()</span><span class="o">.</span><span class="n">__aiter__</span><span class="p">()</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">row</span> <span class="o">=</span> <span class="k">await</span> <span class="n">i</span><span class="o">.</span><span class="n">__anext__</span><span class="p">()</span>
    <span class="k">except</span> <span class="nb">StopAsyncIteration</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</code></pre></div></div>

<p>Differences between ‘native coroutines’ and ‘generator coroutines’:
 Great effort has been made to make sure that coroutines and generators are treated as distinct concepts:
- Native coroutine objects do not implement <strong>iter</strong> and <strong>next</strong> methods. Therefore, they cannot be iterated over or passed to iter() , list() , tuple() and other built-ins. They also cannot be used in a for..in loop.
- An attempt to use <strong>iter</strong> or <strong>next</strong> on a native coroutine object will result in a TypeError .
- Plain generators cannot yield from native coroutines : doing so will result in a TypeError .
- generator-based coroutines (for asyncio code must be decorated with @asyncio.coroutine) can yield from native coroutine objects .
- inspect.isgenerator() and inspect.isgeneratorfunction() return False for native coroutine objects and native coroutine functions .
See https://hg.python.org/cpython/rev/7a0a1a4ac639,
http://bugs.python.org/issue24400 for why ‘native coroutines’ have a
different type from generators.</p>

<p>http://stackoverflow.com/questions/32582573/generator-based-coroutine-versus-native-coroutine
- Generators are iterable, and native coroutines are not.
- await foo is an expression whereas yield from foo is a statement, which means await can be used in places that yield from cannot.
- Native coroutines also permit new syntaxes like async context managers and async iterators. (because they are wrapped in awaitable)
- Coroutines have useful debugging messages, e.g. a warning if you never await a coroutine object.</p>

<p>http://stackoverflow.com/questions/39671950/is-there-any-reason-to-use-pythons-generator-based-coroutines-over-async-await?rq=1
At the end of the chain we need a ‘generator based coroutine’ to yield the
values (a ‘native coroutine’ can only return once). In practice
“coroutines yield asyncio.Future objects up to the event loop, and the event loop sends those same future objects back into the coroutine once the associated operations have been completed (they are typically scheduled via call_soon() and the other event loop methods)”
-&gt; reference the very interesting thread on pep482: https://mail.python.org/pipermail/python-dev/2015-April/thread.html#139728</p>

<h2 id="asynchronous-generators">Asynchronous generators</h2>
<p>A generator allows to easily implement an iterable (<strong>iter</strong>,<strong>next</strong>),
while an asynchronous generator allow to easily implement an asynchronous
iterable (<strong>aiter</strong>, <strong>anext</strong>)</p>

<p>https://www.python.org/dev/peps/pep-0525/
~~~ python
class Ticker:
    “"”Yield numbers from 0 to <code>to</code> every <code>delay</code> seconds.”””</p>

<pre><code>def __init__(self, delay, to):
    self.delay = delay
    self.i = 0
    self.to = to

def __aiter__(self):
    return self

async def __anext__(self):
    i = self.i
    if i &gt;= self.to:
        raise StopAsyncIteration
    self.i += 1
    if i:
        await asyncio.sleep(self.delay)
    return i
</code></pre>

<p>async def ticker(delay, to):
    “"”Yield numbers from 0 to <code>to</code> every <code>delay</code> seconds.”””
    for i in range(to):
        yield i
        await asyncio.sleep(delay)</p>

<h2 id="summary">Summary</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">func</span><span class="p">():</span>            <span class="c1"># a function
</span>    <span class="k">return</span>

<span class="k">def</span> <span class="nf">genfunc</span><span class="p">():</span>         <span class="c1"># a generator function
</span>    <span class="k">yield</span>
<span class="c1">#=&gt; this produce an iterable, ie with a __iter__ and __next__
</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">coro</span><span class="p">():</span>      <span class="c1"># a coroutine function
</span>    <span class="k">await</span> <span class="n">smth</span><span class="p">()</span>
<span class="c1">#=&gt; it is awaitable, ie with a __await__
#(both coro and genfunc have a send, throw, close)
</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">asyncgen</span><span class="p">():</span>  <span class="c1"># an asynchronous generator function
</span>    <span class="k">await</span> <span class="n">smth</span><span class="p">()</span>
    <span class="k">yield</span> <span class="mi">42</span>
<span class="c1">#=&gt; this produce an async iterable, ie with a __aiter__ and __anext__,
</span>    <span class="ow">and</span> <span class="n">asend</span><span class="p">,</span> <span class="n">athrow</span><span class="p">,</span> <span class="n">aclose</span>

<span class="c1">## Ex: generator
</span><span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">i</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">():</span>
  <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="c1">### Manually:
</span><span class="n">g</span><span class="o">=</span><span class="n">gen</span><span class="p">()</span>
<span class="n">g</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
<span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

<span class="c1">## Coroutine generator
</span><span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="o">*</span>
<span class="o">@</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">coro</span><span class="p">():</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">i</span>
<span class="c1">### Note: coro is still a generator, c=coro() has __next__ but not __anext__
</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">coro</span><span class="p">():</span>
  <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
  <span class="k">await</span> <span class="n">coro</span><span class="p">()</span>

<span class="n">b</span><span class="o">=</span><span class="n">bar</span><span class="p">()</span>
<span class="n">b</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">agen</span><span class="p">():</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">i</span>

<span class="k">async</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">agen</span><span class="p">():</span>
  <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">coros</span><span class="p">):</span>
    <span class="n">coros</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coros</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">coros</span><span class="p">:</span>
        <span class="c1"># Duplicate list for iteration so we can remove from original list.
</span>        <span class="k">for</span> <span class="n">coro</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">coros</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">coro</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="k">except</span> <span class="nb">StopIteration</span><span class="p">:</span>
                <span class="n">coros</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
</code></pre></div></div>

<pre><code>                     ======================== 0) Genrators as iterators for i in foo: =&gt; iter=foo.__iter__() puis next(iter)... A genrator function returns a generator object: o=gen() where o.__iter__() is simply o.
</code></pre>

<p>1) async from generators
def foo:
  yield from bar()
end
def bar:
  yield blocking_stuff
  return 42</p>

<p>=&gt; The trampoline calls foo; which transfer to bar. The yield transfer back
‘blocking_stuff’ to the trampoline. The trampoline can launch other
procedures waiting for ‘blocking_stuff’ to be fullfilled. It then resumes
back bar, which returns 42; which is the value of ‘yield from bar()’.
In async_io ‘blocking_stuff’ est une future, où
   def <strong>iter</strong>:
     if not self.done():
       # - Set by <strong>iter</strong>() below so that Task._step() can tell
       #   the difference between <code>yield from Future()</code> (correct) vs.
       #   <code>yield Future()</code> (incorrect).
       self._asyncio_future_blocking = True
       yield self  # This tells Task to wait for completion.
ie asyncio demande explicitement qu’on fasse ‘yield from blocking_stuff’
plutôt que ‘yield blocking_stuff’ (qui marcherait en fait). Ca permet de
prendre le réflexe de mettre des ‘yield from’ partout, ie d’éviter ‘yield
bar()’ qui lui ne marcherait pas.
Ensuite quand asyncio reçoit une future dans le ‘yield from future()’, il
fait <code>future.add_done_callback(self._wakeup)</code>.</p>

<p>2) async/await
Quand on se sert des générateurs dans 1), il n’y a que le plus bas niveau
qui a besoin d’être un vrai générateur; les fonctions intermédiaires ne
font que faire du transfert en appelant ‘yield from’. Pour ces fonctions
intermédiaires, on va donner le nouveau type ‘coroutines’ avec async/await.
Si c=coro(), c est une coroutine object, et c.<strong>await</strong>() donne
l’équivalent de asyncio ensure_future(c), ie wrappe c dans une generator
based coroutine:
def wrap(c)
  return (yield from c.<strong>await</strong>)</p>

<p>Cf the doc:
https://docs.python.org/3/reference/datamodel.html#object.<strong>await</strong>
object.<strong>await</strong>(self)
    Must return an iterator. Should be used to implement awaitable objects. For instance, asyncio.Future implements this method to be compatible with the await expression.</p>

<p>3.4.2. Coroutine Objects
Coroutine objects are awaitable objects. A coroutine’s execution can be controlled by calling <strong>await</strong>() and iterating over the result. When the coroutine has finished executing and returns, the iterator raises StopIteration, and the exception’s value attribute holds the return value. If the coroutine raises an exception, it is propagated by the iterator. Coroutines should not directly raise unhandled StopIteration exceptions.</p>

<p>types.coroutine(gen_func)
    This function transforms a generator function into a coroutine function which returns a generator-based coroutine. The generator-based coroutine is still a generator iterator, but is also considered to be a coroutine object and is awaitable. However, it may not necessarily implement the <strong>await</strong>() method.</p>

<p>=&gt; coroutines based generator: flag a generator with types.coroutine – technically the flag is the CO_ITERABLE_COROUTINE
wheras CO_COROUTINE is used to mark native coroutines (defined with new syntax).
=&gt; yield from checks for <strong>iter</strong> while await checks for <strong>await</strong> OR a
coroutine based generator</p>

<h1 id="classes">Classes</h1>

<p>x=0
class Foo:
  x=1 #Foo.x=1 (ie class variables map to class attributes)
  def f(self,y):
    return x+y #x refer to the global x(x=0) here
Foo().f(3)</p>

<p>A class is just a package of (method) attributes with inheritence chain:
class Foo(Bar,Baz) look at the inheritence of Bar then of Baz
Foo.<strong>bases</strong> list the super classes of Foo
obj=Foo() #instance
obj.method(ploum) is a syntaxtic shortcut for Foo.method(obj,ploum)</p>

<p>In python2 Foo.f is an unbound method, whild in python3 Foo.f is simply a
function (so it gives an easy way to to get static class methods)</p>

<h2 id="classes-and-functions">Classes and functions</h2>
<p>Foo.f =&gt; function (in python3, unbound method in python 2)
Foo().f =&gt; bound method</p>

<p>One can also define class methods by assigning functionals:
~~~ python
def f(self):
  print(self)
class Foo:
  fun=f
  l=lambda x: x
foo=Foo(); foo.fun(); foo.l()
~~~</p>

<h2 id="new-style-classes">New style classes</h2>

<p>In python2 old-style classes, attribute search is done in a depth first way
(starting on the left superclass).
In python3 we have new-style classes, to get them in python2 we need to
subclass object.
In this case the search is done in a breadth like fashion for diamond
shaped inheritence. The order of the search is available via Foo.<strong>mro</strong>:
~~~ python
class Bar: pass
class Baz: pass
class Foo: pass
class Foo(Bar,Baz): pass
Foo.<strong>mro</strong> #=&gt;(&lt;class ‘<strong>main</strong>.Foo’&gt;, &lt;class ‘<strong>main</strong>.Bar’&gt;, &lt;class ‘<strong>main</strong>.Baz’&gt;, &lt;class ‘object’&gt;)
~~~</p>

<p>In new style:
- all classes inherit from object
- The super keyword looks through the mro inheritence chain
- A class can define <strong>slots</strong> to restrict the attributes available to
  instances
- type(obj) returns the class of obj
  type(Class) is ‘type’, a metaclass is simply a subclass of type.
- buitin functions don’t call <strong>getattr</strong> and <strong>getattribute</strong> on instance
  but on class.
  Ie before X[I] was X.<strong>getitem</strong>(I) but now is type(X).<strong>getitem</strong>(X,I)</p>

<p>Ex: slots
~~~ python
class Foo: pass
foo=Foo()
foo.<strong>dict</strong> #hash managing foo’s attributes
class Bar:
  <strong>slots</strong>=[‘age’,’name’]
end
bar=Bar()
bar.name=”bar” #ok
bar.foo=”foo” #=&gt;AttributeError: ‘Bar’ object has no attribute ‘foo’
bar.<strong>slots</strong> #=&gt;[‘age’, ‘name’]
bar.<strong>dict</strong> #=&gt;AttributeError: ‘Bar’ object has no attribute ‘<strong>dict</strong>’
~~~
Note: one can cheat by putting <strong>dict</strong> in the <strong>slots</strong> array, this give
back non slots attributes access</p>

<p>For all magic methods, cf http://www.rafekettler.com/magicmethods.html
For instance, to make an instance callable as a function, use <strong>call</strong>
~~~ python
class Foo:
  def <strong>init</strong>(self,x):
    self.x=x
  def <strong>call</strong>(self,y):
    return self.x+y</p>

<p>foo=Foo(2)
foo(3) #=&gt; 5
~~~</p>

<h1 id="decorators-and-descriptors">Decorators and descriptors</h1>

<h2 id="decorator">Decorator</h2>
<p>http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/</p>

<p>@foo
def f:
  …
Replace f by foo(f)</p>

<p>For instance to define a static method, use
@staticmethod
def f…
(In python 2 this is the only way to call a class method. In python 3,
Class.instance returns a function rather than an unbound method, so it can
be called directly. The @classmethod is still useful to call it from an
instance (because otherwise the instance would try to call the method f by
passing ‘self’ as first argument)
Cf http://stackoverflow.com/questions/735975/static-methods-in-python</p>

<p>Use @classmethod to define a class method
@classmethod
def f(cls,args) #here cls refer to the class</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">#via a function
</span><span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="c1">#1
</span>        <span class="k">print</span> <span class="s">"Arguments were: </span><span class="si">%</span><span class="s">s, </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1">#2
</span>    <span class="k">return</span> <span class="n">inner</span>
 <span class="c1">#Notice our inner function takes any arbitrary number and type of parameters at point #1 and passes them along as arguments to the wrapped function at point #2. This allows us to wrap or decorate any function, no matter it's signature.
</span><span class="o">@</span><span class="n">logger</span>
<span class="k">def</span> <span class="nf">foo1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>

 <span class="c1">#via an object
</span> <span class="c1">#see: http://www.artima.com/weblogs/viewpost.jsp?thread=240808
</span><span class="k">class</span> <span class="nc">myDecorator</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">=</span><span class="n">f</span>
  <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Self is: </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Arguments were: </span><span class="si">%</span><span class="s">s, </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="o">@</span><span class="n">myDecorator</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
<span class="k">print</span><span class="p">(</span><span class="n">foo</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="c1">#self if myDecorator; Arguments were: (3,), {} =&gt; 4
</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
  <span class="o">@</span><span class="n">myDecorator</span>
  <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"In foo"</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
 <span class="c1">#this does not work because when Foo().foo is wrapped myDecorator it is just a function, not yet a method. So in myDecorator, 'self.f' refer to the foo with self unbound. Now when called, since foo is now a myDecorator and not an instance method, it won't get passed the current instance as parameter. This would work with a function wrapper for decorator because it would still be interpreted as a class method
</span><span class="k">print</span><span class="p">(</span><span class="n">Foo</span><span class="p">()</span><span class="o">.</span><span class="n">foo</span><span class="p">())</span>
</code></pre></div></div>

<p>See: http://stackoverflow.com/questions/306130/python-decorator-makes-function-forget-that-it-belongs-to-a-class
and http://www.ianbicking.org/blog/2008/10/decorators-and-descriptors.html
A trick to solve the above problem for instance methods is to combine the
decorator with a descriptor
~~~ python
    def <strong>get</strong>(self, obj, type=None):
        if obj is None:
            return self
        new_func = self.func.<strong>get</strong>(obj, type) #curry the function with the instance ‘obj’ [<em>]
        return self.<strong>class</strong>(new_func) #we wrap the curried function rather than the original function
        #this works because we use a descriptor to wrap the function at runtime rather than when the method is defined
 #Full example from the stackoverflow answer
class logger(object):
    def <strong>init</strong>(self, func):
        self.func = func
    def <strong>get</strong>(self, obj, type=None):
        return self.<strong>class</strong>(self.func.<strong>get</strong>(obj, type))
    def <strong>call</strong>(self, *args, **kw):
        print ‘Entering %s’ % self.func
        return self.func(</em>args, <em>*kw)
class C(object):
    @logger
    def f(self, x, y):
        return x+y
C().f(1, 2)
 # =&gt; Entering &lt;bound method C.f of &lt;<strong>main</strong>.C object at 0x…»
~~~
[</em>] Indeed according to https://docs.python.org/2/howto/descriptor.html,
the way a function is transformed to a method is via <strong>get</strong>:
~~~ python
class Function(object):
    def <strong>get</strong>(self, obj, objtype=None):
        “Simulate func_descr_get() in Objects/funcobject.c”
        return types.MethodType(self, obj, objtype)
~~~</p>

<h2 id="descriptor">Descriptor</h2>

<p>class Descriptor
  def <strong>get</strong>: pass
  def <strong>set</strong>: pass</p>

<p>class Foo
  foo=Descriptor() #use setter and getter from Descriptor</p>

<p>Ex: http://stackoverflow.com/questions/3798835/understanding-get-and-set-and-python-descriptors
~~~ python
class Celsius(object):
    def <strong>init</strong>(self, value=0.0):
        self.value = float(value)
    def <strong>get</strong>(self, instance, owner):
        #we store the property in the descriptor (=self=Celsius instance)
        #rather than the Temperature instance (=instance)
        return self.value
    def <strong>set</strong>(self, instance, value):
        self.value = float(value)
class Temperature(object):
    celsius = Celsius()</p>

<p>class Celsius:
    def <strong>get</strong>(self, instance, owner): return 9 * (instance.fahrenheit + 32) / 5
    def <strong>set</strong>(self, instance, value): instance.fahrenheit = 32 + 5 * value / 9
class Temperature:
    def <strong>init</strong>(self, initial_f): self.fahrenheit = initial_f
    celsius = Celsius()
t = Temperature(212)
print(t.celsius)
t.celsius = 0
print(t.fahrenheit)
~~~</p>

<p>Shortcut: ‘property(getter,setter…)’ or ‘@property attribute’
See http://stackoverflow.com/questions/17330160/how-does-the-property-decorator-work
~~~ python
class C(object):
    def <strong>init</strong>(self):
        self._x = None
    def getx(self):
        return self._x
    def setx(self, value):
        self._x = value
    def delx(self):
        del self._x
    x = property(getx, setx, delx, “I’m the ‘x’ property.”)
#via a decorator
class C(object):
    def <strong>init</strong>(self):
        self._x = None
    @property
    def x(self):
        “"”I’m the ‘x’ property.”””
        return self._x
    @x.setter
    def x(self, value):
        self._x = value
    @x.deleter
    def x(self):
        del self._x
~~~
The Descriptor Howto includes a pure python sample implementation of the property() type:
~~~ python
    class Property(object):
        “Emulate PyProperty_Type() in Objects/descrobject.c”</p>

<pre><code>    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        if doc is None and fget is not None:
            doc = fget.__doc__
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError("unreadable attribute")
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError("can't set attribute")
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError("can't delete attribute")
        self.fdel(obj)

    def getter(self, fget):
        return type(self)(fget, self.fset, self.fdel, self.__doc__)

    def setter(self, fset):
        return type(self)(self.fget, fset, self.fdel, self.__doc__)

    def deleter(self, fdel):
        return type(self)(self.fget, self.fset, fdel, self.__doc__) ~~~
</code></pre>

<h1 id="metaclasses">Metaclasses</h1>

<p>class ploum(metaclass=foo)
end
http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</p>

<p>add a <strong>metaclass</strong> attribute to ploum, so that class(ploum) is foo
The attribute lookup is as follow:
- look first on <strong>bases</strong> as the <strong>mro</strong> (for an instance, there is no
  superclasses, so only look on the instance)
- then go to the class, and search the <strong>mro</strong> there (so for a class we go
  to the metaclass after superclasses)
There is a special case for handling descriptors (a descriptor with <strong>set</strong>
is prioritary to the whole scheme), and builtins go directly to step 2
(they skip the instance attribute)</p>

<p>In more details:
To look up an explicit attribute name:
1. From an instance I, search the instance, then its class, and then all its superclasses, using:
a. The <strong>dict</strong> of the instance I
b. The <strong>dict</strong> of all classes on the <strong>mro</strong> found at I’s <strong>class</strong> , from left to right
2. From a class C, search the class, then all its superclasses, and then its metaclasses tree, using:
a. The <strong>dict</strong> of all classes on the <strong>mro</strong> found at C itself, from left to right
b. The <strong>dict</strong> of all metaclasses on the <strong>mro</strong> found at C’s <strong>class</strong> , from
left to right
3. In both rule 1 and 2, give precedence to data descriptors located in step b sources
4. In both rule 1 and 2, skip step a and begin the search at step b for built-in operations
[Note: step 3 is even more crazy than that, data descriptors in classes
override the object attributes if they have a setter but not if they only
have a getter. See the diagram in the link below]</p>

<p>https://docs.python.org/3/reference/datamodel.html#invoking-descriptors
http://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/</p>

<h1 id="examples">Examples</h1>
<p>## read json file encoding information on servers (was used in offlineimap.py)
 #recursive merge from http://stackoverflow.com/questions/7204805/dictionaries-of-dictionaries-merge
def mergedicts(dict1, dict2):
    for k in set(dict1.keys()).union(dict2.keys()):
        if k in dict1 and k in dict2:
            if isinstance(dict1[k], dict) and isinstance(dict2[k], dict):
                yield (k, dict(mergedicts(dict1[k], dict2[k])))
            else:
                # If one of the values is not a dict, you can’t continue merging it.
                # Value from second dict overrides one in first and we move on.
                yield (k, dict2[k])
                # Alternatively, replace this with exception raiser to alert you of value conflicts
        elif k in dict1:
            yield (k, dict1[k])
        else:
            yield (k, dict2[k])</p>

<p>if serverdict is None:
  file=open(os.environ[‘HOME’]+”/mine/config/.authinfo”)
  serverdict=json.load(file)
  auth = subprocess.check_output([“gpg”, “–no-tty”, “-d”, os.environ[‘HOME’]+”/mine/config/.authinfo.gpg”]).decode(“utf-8”)
  serverdict=dict(mergedicts(serverdict,json.loads(auth)))
  #print(serverdict)</p>

<h1 id="asyncio">Asyncio</h1>
<p>Originally called tulip
Pep: https://www.python.org/dev/peps/pep-3156/</p>

<p>asyncio is the event loop in the stdlib of python
- Cf https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/
for the link with async/await
- Some Thoughts on Asynchronous Programming
  http://python-notes.curiousefficiency.org/en/latest/pep_ideas/async_programming.html#using-special-methods-in-explicitly-asynchronous-code
  “One challenge that arises when writing explicitly asynchronous code is how to compose it with other elements of Python syntax like operators, for loops and with statements. The key to doing this effectively is the same as that adopted when designing the concurrent.futures.as_completed() iterator API: these other operations should always return a Future or coroutine object, even if the result of the operation happens to be available immediately. This allows the user code to consistently retrieve the result via yield from. The implementation of <strong>iter</strong> on Future objects and coroutines is such that they will return immediately if the result is already available, avoiding the overhead of a trip through the event loop.” =&gt; this explain why ‘await’ is similar to ‘yield from’</p>

<p>Other event librairies:
- http://www.gevent.org/
  gevent is a coroutine -based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev event loop. (greenlets are like ruby fibers)
- https://github.com/dabeaz/curio
  Curio - The coroutine concurrency library.
- http://trollius.readthedocs.io/index.html
  Port of asyncio to python2 (using yield since yield from does not exist and
  wrapping the objects in Future)
- twisted https://twistedmatrix.com/trac/
  Twisted is an event-driven networking engine written in Python</p>

<p>https://docs.python.org/3/library/asyncio-task.html#future
  A mix between a future and a promise (because of the ‘add_done_callback’)
  ‘This class is almost compatible with concurrent.futures.Future https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future’</p>

<p>Exemples:
- How to use asyncio ensure_future to act as a trampoline https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future
  http://stackoverflow.com/questions/30380110/mutually-recursive-coroutines-with-asyncio (Note: one could also use asyncio’s queue to send messages between the
  two coroutines rather than wrap the results into future)
  http://calebmadrigal.com/recursion-with-asyncio/</p>

<p>Implementation:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># cpython/Lib/asyncio:
</span> <span class="c1"># - coroutine.py
</span> <span class="c1"># flag a generator as a 'coroutine'
</span> <span class="c1"># also support awaitables and functions returning a future, not just generators
</span> <span class="c1"># so that when wrapping a future result the return value is the result of
</span> <span class="c1"># the future, not the future itself.
</span> <span class="c1"># Note types.coroutine only flags a generator as a coroutine, cf Lib/types.py
</span><span class="k">def</span> <span class="nf">coroutine</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
      <span class="c1"># In Python 3.5 that's all we need to do for coroutines
</span>      <span class="c1"># defined with "async def".
</span>      <span class="k">return</span> <span class="n">func</span>

  <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isgeneratorfunction</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
      <span class="n">coro</span> <span class="o">=</span> <span class="n">func</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="o">@</span><span class="n">functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">coro</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">base_futures</span><span class="o">.</span><span class="n">isfuture</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isgenerator</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="ow">or</span>
              <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">CoroWrapper</span><span class="p">)):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">from</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If 'res' is an awaitable, run it.
</span>            <span class="k">try</span><span class="p">:</span>
                <span class="n">await_meth</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">__await__</span>
            <span class="k">except</span> <span class="nb">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Awaitable</span><span class="p">):</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="k">yield</span> <span class="k">from</span> <span class="n">await_meth</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="n">wrapper</span> <span class="o">=</span> <span class="n">_types_coroutine</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">_is_coroutine</span> <span class="o">=</span> <span class="n">_is_coroutine</span>  <span class="c1"># For iscoroutinefunction().
</span>    <span class="k">return</span> <span class="n">wrapper</span>

<span class="o">-</span> <span class="n">future</span><span class="o">.</span><span class="n">py</span>
 <span class="c1"># yield from future =&gt; this yield the future to the event loop which adds a
</span> <span class="c1"># callback to resume when the future is done (cf __iter__ below)
</span> <span class="c1"># ie this is the way to wait for a future
</span>
<span class="k">class</span> <span class="nc">Future</span><span class="p">:</span>
    <span class="c1"># This field is used for a dual purpose:
</span>    <span class="c1"># - Its presence is a marker to declare that a class implements
</span>    <span class="c1">#   the Future protocol (i.e. is intended to be duck-type compatible).
</span>    <span class="c1">#   The value must also be not-None, to enable a subclass to declare
</span>    <span class="c1">#   that it is not compatible by setting this to None.
</span>    <span class="c1"># - It is set by __iter__() below so that Task._step() can tell
</span>    <span class="c1">#   the difference between `yield from Future()` (correct) vs.
</span>    <span class="c1">#   `yield Future()` (incorrect).
</span>    <span class="n">_asyncio_future_blocking</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__await__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_asyncio_future_blocking</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">yield</span> <span class="bp">self</span>  <span class="c1"># This tells Task to wait for completion.
</span>        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">done</span><span class="p">(),</span> <span class="s">"await wasn't used with future"</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>  <span class="c1"># May raise too.
</span>    <span class="n">__iter__</span> <span class="o">=</span> <span class="n">__await__</span> <span class="c1"># make compatible with 'yield from'.
</span>
<span class="o">-</span> <span class="n">tasks</span><span class="o">.</span><span class="n">py</span>
 <span class="c1"># Essentially the event loop serves as a trampoline for the futures yielded
</span> <span class="c1"># by the coroutines. A coroutine is wrapped into a future via the Task
</span> <span class="c1"># class.
</span>
<span class="k">class</span> <span class="nc">Task</span><span class="p">(</span><span class="n">futures</span><span class="o">.</span><span class="n">Future</span><span class="p">):</span>
    <span class="s">"""A coroutine wrapped in a Future."""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">coroutines</span><span class="o">.</span><span class="n">iscoroutine</span><span class="p">(</span><span class="n">coro</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">coro</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coro</span> <span class="o">=</span> <span class="n">coro</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fut_waiter</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">_all_tasks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">coro</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coro</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fut_waiter</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># We use the `send` method directly, because coroutines
</span>            <span class="c1"># don't have `__iter__` and `__next__` methods.
</span>            <span class="n">result</span> <span class="o">=</span> <span class="n">coro</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">except</span> <span class="nb">StopIteration</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">blocking</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s">'_asyncio_future_blocking'</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">blocking</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># Yielded Future must come from Future.__iter__().
</span>                <span class="k">if</span> <span class="n">blocking</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">_asyncio_future_blocking</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wakeup</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_fut_waiter</span> <span class="o">=</span> <span class="n">result</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">,</span>
                        <span class="nb">RuntimeError</span><span class="p">(</span>
                            <span class="s">'yield was used instead of yield from '</span>
                            <span class="s">'in task {!r} with {!r}'</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># Bare yield relinquishes control for one event loop iteration.
</span>                <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">)</span>
            <span class="k">else</span>
               <span class="c1"># Error a future was not yielded
</span>
    <span class="k">def</span> <span class="nf">_wakeup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c1"># This may also be a cancellation.
</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Don't pass the value of `future.result()` explicitly,
</span>            <span class="c1"># as `Future.__iter__` and `Future.__await__` don't need it.
</span>            <span class="c1"># If we call `_step(value, None)` instead of `_step()`,
</span>            <span class="c1"># Python eval loop would use `.send(value)` method call,
</span>            <span class="c1"># instead of `__next__()`, which is slower for futures
</span>            <span class="c1"># that return non-generator iterators from their `__iter__`.
</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">()</span>

 <span class="c1"># cf http://stackoverflow.com/questions/27076577/yield-from-coroutine-vs-yield-from-task
</span> <span class="c1"># ensure_future wraps a coro inside a Task (which is a future), so that we
</span> <span class="c1"># can start a coroutine in the background
</span><span class="k">def</span> <span class="nf">ensure_future</span><span class="p">(</span><span class="n">coro_or_future</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s">"""Wrap a coroutine or an awaitable in a future.
    If the argument is a Future, it is returned directly.
    """</span>
    <span class="o">=&gt;</span> <span class="k">return</span> <span class="n">coro_or_future</span> <span class="c1">#for a future
</span>    <span class="o">=&gt;</span> <span class="k">return</span> <span class="s">'loop.create_task(coro_or_future)'</span> <span class="c1">#for a coroutine
</span>       <span class="n">which</span> <span class="n">essentially</span> <span class="n">does</span> <span class="s">'tasks.Task(coro_or_future, loop=self)'</span>
    <span class="o">=&gt;</span> <span class="k">return</span> <span class="n">ensure_future</span><span class="p">(</span><span class="n">_wrap_awaitable</span><span class="p">(</span><span class="n">coro_or_future</span><span class="p">),</span> <span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">)</span> <span class="c1">#for an awaitable
</span><span class="o">@</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">_wrap_awaitable</span><span class="p">(</span><span class="n">awaitable</span><span class="p">):</span>
    <span class="s">"""Helper for asyncio.ensure_future().
    Wraps awaitable (an object with __await__) into a coroutine
    that will later be wrapped in a Task by ensure_future().
    """</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">yield</span> <span class="k">from</span> <span class="n">awaitable</span><span class="o">.</span><span class="n">__await__</span><span class="p">())</span>


<span class="o">*</span> <span class="n">Exemple</span><span class="p">:</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="o">@</span><span class="n">asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">test1</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"in test1"</span><span class="p">)</span>

<span class="o">@</span><span class="n">asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">dummy</span><span class="p">():</span>
    <span class="k">yield</span> <span class="k">from</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"dummy ran"</span><span class="p">)</span>

<span class="o">@</span><span class="n">asyncio</span><span class="o">.</span><span class="n">coroutine</span>
<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">test1</span><span class="p">())</span> <span class="c1">#using just 'test1()' would do nothing since it is wrapped into a coroutine object
</span>    <span class="c1">#=&gt; we don't care to wait for the result of test1() in main, we can do other stuff
</span>    <span class="k">yield</span> <span class="k">from</span> <span class="n">dummy</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
 <span class="c1">#=&gt; in test1; dummy ran
</span></code></pre></div></div>

<h1 id="ruby-vs-python">Ruby vs Python</h1>

<p>Legend: + -&gt; Advantage ruby, - -&gt; Advantage python, = -&gt; equality</p>

<p>= In ruby, everything (apart from keywords and variables) is a method call.
This is great for unicity, but this mean that to call a lambda one has to
use l.call(<em>args) or l[</em>args] or l.(<em>args); l(</em>args) will refer to the
method call self.l(*args).
By contrast python has methods (more precisely attributes that are functions) and functions</p>

<ul>
  <li>pry is better than ipython or bpython</li>
  <li>rubygem is much much better than pip. + it is integrated directly on ruby
On python the state fo packaging is not clear cut yet, see
http://stackoverflow.com/questions/6344076/differences-between-distribute-distutils-setuptools-and-distutils2</li>
  <li>python2 vs python3 is a horrible mess</li>
  <li>it’s easier to access docstrings in python (where they are automatically
transformed into attributes) than in ruby where we must use
Method#source_location (or the gem MethodSource that wraps
source_location)</li>
  <li>
    <p>for scientific programming, there is a lot more available in python
(sage, scipython…)</p>
  </li>
  <li>python has multiple inheritences, and the inheritence can be changed at
runtime. Ruby support multiple inheritence which is a bit less flexible
(one can only include module although now on 2.2 refinements can transform
class into modules) and we can only add to the inheritence at runtime (by
dynamic include statements), not remove them (there are C extensions to
manipulate the inheritence chain directly but it is not baked in the
langage)</li>
  <li>ruby has singleton_class. And the singleton_class of a class has for
ancestors the singleton_class of the ancestors of this class. This is
inspired by smalltalk and is so elegant that it solves all metaclass
problems, and allows to have metaclasses of metaclasses. The python
equivalent of metaclass is just subclassing type (in ruby this would be
subclassing Module) and class decorators; this is a lot less flexible</li>
  <li>Likewise in ruby function decorator are simply instance methods of
Module, there is no need for the special @ syntax of python</li>
  <li>python has list/set/hash/generator comprehensions</li>
  <li>ruby has blocks. Blocks are awesome!</li>
  <li>ruby has continuations! And coroutines. Python has generators and
coroutines, but not continuations. Also coroutines are easier to handle in
ruby than in python (where we need decorators)</li>
  <li>ruby has string interpolation directly in the string, there is no need to
call % or format like in python. Also regexp are there by defaut, no need
to load a module</li>
  <li>reduce is there by default, no need to load a module either</li>
  <li>In python3 most of the builtins handling list like objects return
generators; while ruby2 has ‘lazy’ it has to be enabled by hand on an
enumerator, by default it won’t be lazy
= both ruby and python easily support autovivication
cf http://en.wikipedia.org/wiki/Autovivification
http://stackoverflow.com/questions/651794/whats-the-best-way-to-initialize-a-dict-of-dicts-in-python</li>
  <li>
    <p>ruby can be used to replace some of perl’s short oneliners; it uses the
same magic variables convention as perl and the same -F,-p,-e,-n,-a command
lines arguments</p>
  </li>
  <li>python has only lambda that wraps one expression. Also python don’t have
real closures (python functions are like Proc.new in ruby:
~~~ python
x=0
def foo(y):
return x+y
x=1
foo(2) #=&gt;3
~~~
~~~ ruby
x=0; l=lambda {|y| x+y}; x=1; l.call(3) #=&gt;3
 #to check, this now gives 4??
~~~</li>
</ul>
